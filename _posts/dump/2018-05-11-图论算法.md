---
layout: post
category: dump
title: 图论算法
description: Prim算法就是图论算法中的一个问题
---

## 若干定义
- 图由顶点的集和边的集组成。每一条边就是一个点对。如果点对是有序的，那么图就叫做有向图。图中的第三种成分称作权或是值。
- 图中的一条路径是一个定点序列，路径的长是路径上的边数。通常来说，我们讨论的图是无环的。
- 简单路径是指路径上的顶点都是互异的，但是第一个顶点和最后一个顶点可能是相同的。
-  如果在无向图中从每一个定点到其他每一个顶点都存在一条路径，则称该无向图是连通的。具有这样性质的有向图是强连通的。如果有向图不是强连通的，但是它的基础图是连通的，那么成该有向图是弱连通的。
- 如果一个图含有一条从一个顶点到自身的边，那么路径v,v也被称为是环。简单路径是指路径上的所有的顶点都是互异的，但是第一个顶点和最后一个顶点可能是同一个顶点。
### 拓扑排序
　　拓扑排序是对有向无环图的所有顶点的一个线性排序，这个序列必须满足下面的这些条件：
- 每个顶点出现且只出现一次。
- 若存在一条从顶点A到顶点B的路径，那么在序列中顶点A出现在顶点B的前面。<br>
　　如何得到一个有向无环图的拓扑序列呢？通常的一种方法是：
- 从ＤＡＧ图中选择一个没有前驱的顶点并输出
- 从图中删除该顶点和所有以它为起点的有向边
- 重复1和2直到当前的DAG图为空或是当前图中不存在没有前驱的顶点为止。后一种情况说明有向图中必然存在环。
![](/downloads/拓扑排序.png)
　　得到的拓扑排序就是12435。<br>
　　一个有向无环图的拓扑排序不是唯一的。

### 树的概念
　　首先说一下树的概念，这在后面还是非常重要的一个概念：
- 树的标准定义是：树是包含n个节点的有穷集合，其中 每个元素称为是节点;有一个特定的节点是被称为是根节点或是树根。除了根节点以外的其余的元素是被分为m个互不相交的结合T1、T2、T3……其中每一个集合本身也是一棵树，被称为是原树的子树。

### 最小生成树
　　一个有n个结点的连通图的生成树是原图的极小连通子图，包含原图中所有的n个结点，并且保持连通图的最少的边。最小生成树可以有Prim和Kruskal算法求出。

### 广度优先算法和深度优先算法和
　　深度优先算法的思想是：首先以一个未被访问过的顶点作为起始顶点，然后沿着当前顶点的边走到未访问过的顶点，当没有访问过的顶点的时候，则回到上一个顶点，然后继续试探访问别的顶点，知道所有的顶点都被访问了为止。<br>
　　广度优先算法：首先是以一个未被访问过的顶点作为起始顶点，访问它的所有相邻的顶点，然后对每个相邻的顶点再访问它们相邻的未被访问过的顶点，直到所有的顶点都被访问过。<br>

### 最小生成树Prim算法的证明
　　一个无向图G的最小生成树就是有该图的那些连接G的所有顶点的边构成的一个树，且其总值最低。最小生成树存在当且仅当G是连通的——在无向图中，从每一个顶点到其他一个顶点都存在一条路径。最小生成树是一棵树，因为它是无环的（所以也就是没有回路的）。因为最小生成树包含每一个顶点，所以是生成树。包含图中所有顶点的最小的树。<br>
　　Prim算法：在算法的任意时刻，我们可以看到一个已经添加到树上的顶点集，其余顶点尚未添加这棵树中。同dijkstra算法一样，我们也可以看作是存在两个集合，一个是存放已经被放在树上的的顶点，另一个是还没有放在树上的顶点，然后不断将后面集合中的顶点放在第一个集合中。算法在每一个阶段都可以通过选择边(u,v)，使得(u,v)的值是所有u在树上、但是v不在树上的边的值中的最小者——实际上也是广度优先的一个算法。<br>
　　对Prim算法的一个证明：
- 首先选择第一个边的时候选择的权值是最小的（如果一个图中边的权值是唯一的，那么得到的最小生成树是唯一的，如果有权值是相同的话的，那么得到的最小生成树可能就不是唯一的了）。<br>
　　简单证明Ｐｒｉｍ算法：
- 假设Prim算法生成的不是最小生成树，设Prim算法对应的生成树是G0
- 假设存在Gmin使得该树的值比Prim算法生成的树的值要小，那么Gmin中一定是有一条边<u,v>是不属于G0的
- 将<u,v>加入G0,可以得到一个回路，而且这个<u.v>不是这个环路中的最小的边。（因为<u,v>是来自最小生成树的，对于G0来说，一定至少存在一条边是大于Gmin中的各个边的，同理也可以用反正法来证明，假如每条边都是小于等于的话，那么G0的值不会大于Gmin）
- 因为<u,v>不是回路中最小的边，这和Prim算法每次都寻找最小的边的原则是矛盾的
- 所以假设是不成立的，故Prim算法生成的是最小生成树，得证。